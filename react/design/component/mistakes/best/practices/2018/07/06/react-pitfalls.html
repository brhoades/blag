<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>React Pitfalls</title>
  <meta name="description" content="Introduction React has some common pitfalls that I’ve seen developers fall into when designing components. The most common center around readability and perf...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/react/design/component/mistakes/best/practices/2018/07/06/react-pitfalls.html">
  <link rel="alternate" type="application/rss+xml" title="Billy Rhoades" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Billy Rhoades</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">React Pitfalls</h1>
    <p class="post-meta"><time datetime="2018-07-06T13:00:00-05:00" itemprop="datePublished">Jul 6, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>React has some common pitfalls that I’ve seen developers fall into when designing components. The most common center around readability and performance. Now, there’s easily a dozen <a href="http://americanexpress.io/clean-code-dirty-code/">articles</a> <a href="https://engineering.musefind.com/our-best-practices-for-writing-react-components-dec3eb5c3fc8">about</a> <a href="https://reactjs.org/docs/thinking-in-react.html">React</a> <a href="https://preact.gitbooks.io/react-book/content/jsx/index.html">best</a> <a href="https://blog.andrewray.me/youre-missing-the-point-of-jsx/">practices</a> but these lean abstract with contrived examples. Personally, I find it much easier to see where people made mistakes, see how we fixed them, and then break those examples down.</p>

<h2 id="nested-component-definitions">Nested Component Definitions</h2>
<p>Defining components within components breaks reusability, causes unnecessary rendering, and crowds files. It’s particularly tempting to nest components when one component needs variables from the other, but it leads to coupling. Nesting components will always lead to rerenders of child compoents when any prop in the parent component is changed. Fortunately, it’s easy to fix and fairly easy to diagnose.</p>

<h3 id="recommended-reading">Recommended Reading</h3>
<ul>
  <li><a href="https://reactjs.org/docs/rendering-elements.html">React Documentation: rendering elements</a></li>
  <li><a href="https://medium.com/@ryanbas21/react-reconciliation-7075e3f07437">React Reconciliation</a></li>
</ul>

<h3 id="bad">Bad</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Section</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">description</span><span class="p">,</span> <span class="nx">footer</span><span class="p">,</span> <span class="nx">header</span><span class="p">,</span> <span class="nx">items</span><span class="p">,</span> <span class="nx">sectionId</span><span class="p">,</span> <span class="nx">onChange</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">Item</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">label</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">React</span><span class="p">.</span><span class="nx">Fragment</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Header</span> <span class="nx">size</span><span class="o">=</span><span class="s2">"small"</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">label</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/Header</span><span class="err">&gt;
</span>      <span class="p">{</span><span class="nx">content</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="nx">Input</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">onChange</span><span class="p">(</span><span class="nx">sectionId</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Spacer</span> <span class="nx">size</span><span class="o">=</span><span class="s2">"small"</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/React.Fragment</span><span class="err">&gt;
</span>  <span class="p">);</span>
  
  <span class="kd">const</span> <span class="nx">Content</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">label</span> <span class="p">},</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Item</span>
        <span class="nx">content</span><span class="o">=</span><span class="p">{</span><span class="nx">content</span><span class="p">}</span>
        <span class="nx">label</span><span class="o">=</span><span class="p">{</span><span class="nx">label</span><span class="p">}</span>
        <span class="nx">index</span><span class="o">=</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span>
        <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s2">`</span><span class="p">${</span><span class="nx">sectionId</span><span class="p">}${</span><span class="nx">label</span><span class="p">}</span><span class="s2">`</span><span class="p">}</span>
      <span class="sr">/</span><span class="err">&gt;
</span>    <span class="p">));</span>
  <span class="p">);</span>
  
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Card</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Header</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">header</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/Header</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Content</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">Footer</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">footer</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/Footer</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Card</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Here you can see a section component which, within it, defines an Item component and a Content component. Defining an internal Content component here is only a coupling issue. However, defining Item within this component is going to cause some pain. Item is defined within this component because it’s only used by Section and it needs sectionId and onChange from Section.</p>

<p>However, defining the component within Section causes Item to be redefined and rerendered every time any Section prop changes. Any Inputs on the page will be destroyed and mounted again within the DOM. If you were typing into an Input component and a Section prop changed, your focus would be lost. I’ve ran into this scenario quite a few times— onChange updates Section’s items which causes a rerender.</p>

<p>If Item were moved outside of Section, React would behave differently.</p>

<h3 id="good">Good</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Item</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">label</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">onChange</span><span class="p">,</span> <span class="nx">sectionId</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">React</span><span class="p">.</span><span class="nx">Fragment</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Header</span> <span class="nx">size</span><span class="o">=</span><span class="s2">"small"</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">label</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/Header</span><span class="err">&gt;
</span>    <span class="p">{</span><span class="nx">content</span><span class="p">}</span>
    <span class="o">&lt;</span><span class="nx">Input</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">onChange</span><span class="p">(</span><span class="nx">sectionId</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">Spacer</span> <span class="nx">size</span><span class="o">=</span><span class="s2">"small"</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="sr">/React.Fragment</span><span class="err">&gt;
</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">Section</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">description</span><span class="p">,</span> <span class="nx">footer</span><span class="p">,</span> <span class="nx">header</span><span class="p">,</span> <span class="nx">items</span><span class="p">,</span> <span class="nx">sectionId</span><span class="p">,</span> <span class="nx">onChange</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">content</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">label</span> <span class="p">},</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Item</span>
      <span class="nx">content</span><span class="o">=</span><span class="p">{</span><span class="nx">content</span><span class="p">}</span>
      <span class="nx">label</span><span class="o">=</span><span class="p">{</span><span class="nx">label</span><span class="p">}</span>
      <span class="nx">index</span><span class="o">=</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span>
      <span class="nx">sectionId</span><span class="o">=</span><span class="p">{</span><span class="nx">sectionId</span><span class="p">}</span>
      <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">onChange</span><span class="p">}</span>
      <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s2">`</span><span class="p">${</span><span class="nx">sectionId</span><span class="p">}${</span><span class="nx">label</span><span class="p">}</span><span class="s2">`</span><span class="p">}</span>
    <span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">));</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Card</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Header</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">header</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/Header</span><span class="err">&gt;
</span>      <span class="p">{</span><span class="nx">content</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="nx">Footer</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">footer</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/Footer</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Card</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>As mentioned above, with Item defined outside of section any changes to Section’s props which don’t affect Item’s props will not cause a rerender. <a href="https://reactjs.org/docs/rendering-elements.html#react-only-updates-whats-necessary">Only components with modified props will be updated</a>. Input’s focus will not be lost as long as its props aren’t changed. We save unnecessary renders here and remove future coupling issues.</p>

<h2 id="abusing-keys">Abusing Keys</h2>
<p>Keys in React are used when returning procedurally generated components. One of the most common uses is an array of values which will be individually passed into equally many components, as can be seen below. React’s <a href="https://reactjs.org/docs/lists-and-keys.html#keys">documentation describes this well</a>:</p>

<blockquote>
  <p>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity.</p>
</blockquote>

<p>Unfortunately, keys aren’t always available inside a data source. When not available, keys can be chosen that aren’t stable between renders or not unique among sibling components. React’s documentation <a href="https://reactjs.org/docs/reconciliation.html#tradeoffs">mentions this</a>:</p>

<blockquote>
  <p>Keys should be stable, predictable, and unique. Unstable keys (like those produced by Math.random()) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</p>
</blockquote>

<p>In a pinch, using the array index may suffice. However, I’m in the camp that index as a key is an antipattern; you only do this until you encounter a bug from it. Bugs resulting from index as a key are incredibly difficulty to diagnose; they usually arise from where components that have state are change keys. The bug’s symptoms will be varied: maybe state tranfers when an element is deleted from an index, or maybe it gets a random state from an older component. You don’t want to learn the symptoms.</p>

<h3 id="recommended-reading-1">Recommended Reading</h3>
<ul>
  <li><a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318">Index as a key is an antipattern</a></li>
  <li><a href="https://reactjs.org/docs/lists-and-keys.html">React documentation: Keys</a></li>
  <li><a href="https://reactjs.org/docs/reconciliation.html#recursing-on-children">React documentation: Recursing on Children</a></li>
</ul>

<h3 id="bad-1">Bad</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">shortid</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'shortid'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">Quiz</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">sections</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="p">{</span>
        <span class="nx">sections</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">section</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
          <span class="o">&lt;</span><span class="nx">Section</span>
            <span class="p">{...</span><span class="nx">section</span><span class="p">}</span>
            <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">shortid</span><span class="p">.</span><span class="nx">generate</span><span class="p">()}</span>
          <span class="sr">/</span><span class="err">&gt;
</span>        <span class="p">))</span>
      <span class="p">}</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>We’re using <a href="https://github.com/dylang/shortid#usage">shortid</a> to generate a unique, per render random key for our sections. This would be a nonissue if sections never change position or the list never changes size. However, if sections does change, it’s possible that there could be <a href="https://reactjs.org/docs/reconciliation.html#recursing-on-children">performance issues</a> or <a href="https://codepen.io/anon/pen/ParyQq">state bugs</a>. This can sometimes be easy to solve… sometimes it’s not.</p>

<h3 id="good-1">Good</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Quiz</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">sections</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="p">{</span>
        <span class="nx">sections</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">section</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
          <span class="o">&lt;</span><span class="nx">Section</span>
            <span class="p">{...</span><span class="nx">section</span><span class="p">}</span>
            <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">section</span><span class="p">.</span><span class="nx">label</span><span class="p">}</span>
          <span class="sr">/</span><span class="err">&gt;
</span>        <span class="p">))</span>
      <span class="p">}</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>The shortid is now swapped for label, which in this case is both unique among all sections and consistent. If you can’t find a key that’s unique, you may find yourself resorting to using an index, but that should be <a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318">a last resort</a>.</p>

<h2 id="redux-overloading-mapstatetoprops">Redux: Overloading mapStateToProps</h2>
<p>With Redux, <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">mapStateToProps</a> is used to subscribe to updates from the store. Any time the store is updated, every component decorated with connect will have its mapStateToProps called. The output of mapStateToProps is then passed to the component via props.</p>

<p>Since mapStateToProps is called on every update, React applications which heavily utilize the store could see a performance impact. For example, if you are storing <a href="https://redux-form.com/7.3.0/">the contents of a form</a> in Redux, every letter typed into a form by a user may trigger a store update. Depending on how your application is laid out, this would trigger every mapStateToProps on every keypress, and possibly trigger rerenders if those result in prop changes.</p>

<p>If there are any mapStateToProps functions that do expensive calculation, such as computing the initial values for the form which a user is inputting into, those will be recalculated <em>every time a change occurs</em>. Since the initial state of a form likely wouldn’t change from user input, it wouldn’t affect the output for mapStateToProps here. However, the calculation would still happen under the hood.</p>

<p>One workaround here is to use <a href="https://github.com/reduxjs/reselect">Reselect</a> in any place where you are performing complex logic within mapStateToProps. Reselect, which behaves very similarly to mapStateToProps, creates a selector. When defining a selector, it needs a list of input functions which will be used to get a list of outputs. The list of outputs are then passed to a result function, which should have any expensive computation in it. From Reselect’s documentation:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// createSelector(...inputSelectors | [inputSelectors], resultFunc)</span>

<span class="kd">const</span> <span class="nx">totalSelector</span> <span class="o">=</span> <span class="nx">createSelector</span><span class="p">(</span>
  <span class="p">[</span>
    <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">value1</span><span class="p">,</span>
    <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">value2</span>
  <span class="p">],</span>
  <span class="p">(</span><span class="nx">value1</span><span class="p">,</span> <span class="nx">value2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value1</span> <span class="o">+</span> <span class="nx">value2</span>
<span class="p">)</span>
</code></pre></div></div>

<p>This example is very simple, but it demonstrates basic usage well. Here we created a selector with two input selectors that grab values from the store. These values are passed through to the result function passed as a second argument to <code class="highlighter-rouge">createSelector</code>. <code class="highlighter-rouge">totalSelector</code> would be used in your mapStateToProps:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">mapStateToProps</span> <span class="o">=</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="na">totalOutput</span><span class="p">:</span> <span class="nx">totalSelector</span><span class="p">(</span><span class="nx">state</span><span class="p">),</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">totalSelector</code> is memoized; it is only called when one of its input selectors return a different value. So if <code class="highlighter-rouge">value1 + value2</code> were an expensive operation that rarely occurred, it would only be called if the two input selectors had changed. This stops expensive computations from occurring when they will provide the same output.</p>

<h2 id="resources">Resources</h2>
<ul>
  <li><a href="https://reactjs.org/docs/optimizing-performance.html">Optimizing React Performance</a></li>
  <li><a href="https://github.com/markerikson/react-redux-links/blob/master/react-architecture.md">Comprehensive React article list for architecting applications</a></li>
</ul>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Billy Rhoades</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Billy Rhoades
            
            </li>
            
            <li><a href="mailto:billyarhoades@gmail.com">billyarhoades@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/brhoades"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">brhoades</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
